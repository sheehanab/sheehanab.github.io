<html>
<body>


  <script>
    function genMoves(){
    // declare initial variables
    var ringNum = document.getElementById("ringNumber").value;
    var numberOfRings = ringNum;
    var numberOfMoves = 0;

	var outStack = [0];
    var outStackIt = 0;
    // declare poles
    var pole1 = [0];
    var pole2 = [0];
    var pole3 = [0];
    for(var i = 1; i <= numberOfRings; i++){
      pole1.push(i);
    }
    // Div elements
    var para = document.createElement('p');
    var div = document.createElement('div');
    
    div.innerHTML = "Generating your steps: ";
    document.getElementById('results').appendChild(div);
    while((pole1[pole1.length-1] != 0) || (pole2[pole2.length-1] !=0)){
      // if the ring number is even
      if(numberOfRings % 2 == 0){
        if(pole1[pole1.length-1] > pole2[pole2.length-1]){
          // copy top ring (pole 1) to next pole
          pole2.push(pole1[pole1.length-1]);
          outStack[outStackIt] = "Move ring size: " + pole1[pole1.length-1] + " from pole 1 --> 2";
          outStackIt++;
          console.log("Move ring size: " + pole1[pole1.length-1] + " from pole 1 --> 2");
          pole1.pop();
        }else{
          outStack[outStackIt] = "Move ring size: " + pole2[pole2.length-1] + " from pole 2 --> 1";
          outStackIt++;
          console.log("Move ring size: " + pole2[pole2.length-1] + " from pole 2 --> 1");
          // copy top of pole 2 to top of pole 1
          pole1.push(pole2[pole2.length-1]);
          // delete top of pole 2
          pole2.pop();
        }
        // increment moves
        numberOfMoves++;
        
        if(pole1[pole1.length-1] > pole3[pole3.length-1]){
          // copy top ring (pole 1) to pole 3
          outStack[outStackIt] = "Move ring size: " + pole1[pole1.length-1] + " from pole 1 --> 3";
          outStackIt++;
          console.log("Move ring size: " + pole1[pole1.length-1] + " from pole 1 --> 3");
          pole3.push(pole1[pole1.length-1]);
          pole1.pop();
        }else{
          outStack[outStackIt] = "Move ring size: " + pole3[pole3.length-1] + " from pole 3 --> 1";
          outStackIt++;
          console.log("Move ring size: " + pole3[pole3.length-1] + " from pole 3 --> 1");
          // copy top of pole 3 to top of pole 1
          pole1.push(pole3[pole3.length-1]);
          // delete top of pole 3
          pole3.pop();
        }
        // increment moves
        numberOfMoves++;
        if(pole2[pole2.length-1] > pole3[pole3.length-1]){
          // copy top ring (pole 2) to pole 3
          pole3.push(pole2[pole2.length-1]);
          outStack[outStackIt] = "Move ring size: " + pole2[pole2.length-1] + " from pole 2 --> 3";
          outStackIt++;
          console.log("Move ring size: " + pole2[pole2.length-1] + " from pole 2 --> 3");
          pole2.pop();
        }else{
          outStack[outStackIt] = "Move ring size: " + pole3[pole3.length-1] + " from pole 3 --> 2";
          outStackIt++;
          console.log("Move ring size: " + pole3[pole3.length-1] + " from pole 3 --> 2");
          // copy top of pole 3 to top of pole 2
          pole2.push(pole3[pole3.length-1]);
          // delete top of pole 3
          pole3.pop();
        }
        // increment moves
        numberOfMoves++;
      }
      // else if ring number is odd
      else if(numberOfRings % 2 == 1){
          if(pole1[pole1.length-1] > pole3[pole3.length-1]){
          // copy top ring (pole 1) to pole 3
          pole3.push(pole1[pole1.length-1]);
          outStack[outStackIt] = "Move ring size: " + pole1[pole1.length-1] + " from pole 1 --> 3";
          outStackIt++;
          console.log("Move ring size: " + pole1[pole1.length-1] + " from pole 1 --> 3");
          pole1.pop();
        }else{
          outStack[outStackIt] = "Move ring size: " + pole3[pole3.length-1] + " from pole 3 --> 1";
          outStackIt++;
          console.log("Move ring size: " + pole3[pole3.length-1] + " from pole 3 --> 1");
          // copy top of pole 3 to top of pole 1
          pole1.push(pole3[pole3.length-1]);
          // delete top of pole 3
          pole3.pop();
        }
        // increment moves
        numberOfMoves++;
        if((pole1[pole1.length-1] != 0) || (pole2[pole2.length-1] != 0)){
          if(pole1[pole1.length-1] > pole2[pole2.length-1]){
            // copy top ring (pole 1) to next pole
            pole2.push(pole1[pole1.length-1]);
            outStack[outStackIt] = "Move ring size: " + pole1[pole1.length-1] + " from pole 1 --> 2";
            outStackIt++;
            console.log("Move ring size: " + pole1[pole1.length-1] + " from pole 1 --> 2");
            pole1.pop();
          }else{
            outStack[outStackIt] = "Move ring size: " + pole2[pole2.length-1] + " from pole 2 --> 1";
            outStackIt++;
            console.log("Move ring size: " + pole2[pole2.length-1] + " from pole 2 --> 1");
            // copy top of pole 2 to top of pole 1
            pole1.push(pole2[pole2.length-1]);
            // delete top of pole 2
            pole2.pop();
          }
          // increment moves
          numberOfMoves++;
          
          if(pole2[pole2.length-1] > pole3[pole3.length-1]){
            // copy top ring (pole 2) to pole 3
            pole3.push(pole2[pole2.length-1]);
            outStack[outStackIt] = "Move ring size: " + pole2[pole2.length-1] + " from pole 2 --> 3";
            outStackIt++;
            console.log("Move ring size: " + pole2[pole2.length-1] + " from pole 2 --> 3");
            pole2.pop();
          }else{
            outStack[outStackIt] = "Move ring size: " + pole3[pole3.length-1] + " from pole 3 --> 2";
            outStackIt++;
            console.log("Move ring size: " + pole3[pole3.length-1] + " from pole 3 --> 2");
            // copy top of pole 3 to top of pole 2
            pole2.push(pole3[pole3.length-1]);
            // delete top of pole 3
            pole3.pop();
          }
          // increment moves
          numberOfMoves++;
        }
        }
     }
      // output moves:
      for(var i = 0; i < numberOfMoves; i++){
        para.innerHTML = para.innerHTML + outStack[i] + "<br />";
      }
      document.getElementById('results').appendChild(para);
      var numMoves = document.createElement('p');
      numMoves.innerHTML = "Number of moves required to solve: " + numberOfMoves;
      document.getElementById('results').appendChild(numMoves);
  }
  </script>
  

<h2>Tower of Hanoi Problem</h2>

<img src="images/Hanoi0.png" alt="Tower of Hanoi">
<br>
<table>
  <div id="towerInput">Number of Rings: <br>
    <input type="text" id="ringNumber"> <br>
    <button onclick="genMoves();">Generate Number of Moves</button>
  </div>
  <div id="results"></div>
  <td>
</table>  
  
<br>
<h3>Summary of the Tower</h3>
<p>The Tower of Hanoi is a game often used to teach recursion. In this game there are three "towers" and any number <i>n</i> of rings.<br>
	The objective is to move all of the rings from the first peg to the last peg, in order. However: <br>
	- You can only move one ring at a time <br>
	- No disk may be placed on top of a smaller disk <br> <br>
	View the image below for an example using 4 rings. <br>
	<img src="images/Tower-of-hanoi.gif" alt="4 Ring Example"> <br> <br>
	For more information check out this <a href="https://www.hackerearth.com/blog/developers/tower-hanoi-recursion-game-algorithm-explained/">site</a>!
	</p>
</body>
</html>

